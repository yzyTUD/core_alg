/*
	src/example1.cpp -- C++ version of an example application that shows
	how to use the various widget classes. For a Python implementation, see
	'../python/example1.py'.

	NanoGUI was developed by Wenzel Jakob <wenzel.jakob@epfl.ch>.
	The widget drawing code is based on the NanoVG demo application
	by Mikko Mononen.

	All rights reserved. Use of this source code is governed by a
	BSD-style license that can be found in the LICENSE.txt file.
*/

#include <nanogui/opengl.h>
#include <nanogui/glutil.h>
#include <nanogui/screen.h>
#include <nanogui/window.h>
#include <nanogui/layout.h>
#include <nanogui/label.h>
#include <nanogui/checkbox.h>
#include <nanogui/button.h>
#include <nanogui/toolbutton.h>
#include <nanogui/popupbutton.h>
#include <nanogui/combobox.h>
#include <nanogui/progressbar.h>
#include <nanogui/entypo.h>
#include <nanogui/messagedialog.h>
#include <nanogui/textbox.h>
#include <nanogui/slider.h>
#include <nanogui/imagepanel.h>
#include <nanogui/imageview.h>
#include <nanogui/vscrollpanel.h>
#include <nanogui/colorwheel.h>
#include <nanogui/colorpicker.h>
#include <nanogui/graph.h>
#include <nanogui/tabwidget.h>
#include <iostream>
#include <string>

// Includes for the GLTexture class.
#include <cstdint>
#include <memory>
#include <utility>

#include <windows.h>

#if defined(__GNUC__)
#  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#endif
#if defined(_WIN32)
#  pragma warning(push)
#  pragma warning(disable: 4457 4456 4005 4312)
#endif

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>

#if defined(_WIN32)
#  pragma warning(pop)
#endif
#if defined(_WIN32)
#  if defined(APIENTRY)
#    undef APIENTRY
#  endif
#  include <windows.h>
#endif

using std::cout;
using std::cerr;
using std::endl;
using std::string;
using std::vector;
using std::pair;
using std::to_string;

class GLTexture {
public:
	using handleType = std::unique_ptr<uint8_t[], void(*)(void*)>;
	GLTexture() = default;
	GLTexture(const std::string& textureName)
		: mTextureName(textureName), mTextureId(0) {}

	GLTexture(const std::string& textureName, GLint textureId)
		: mTextureName(textureName), mTextureId(textureId) {}

	GLTexture(const GLTexture& other) = delete;
	GLTexture(GLTexture&& other) noexcept
		: mTextureName(std::move(other.mTextureName)),
		mTextureId(other.mTextureId), w(other.w), h(other.h) , n(other.n){
		other.mTextureId = 0;
	}
	GLTexture& operator=(const GLTexture& other) = delete;
	GLTexture& operator=(GLTexture&& other) noexcept {
		mTextureName = std::move(other.mTextureName);
		std::swap(mTextureId, other.mTextureId);
		return *this;
	}
	~GLTexture() noexcept {
		if (mTextureId)
			glDeleteTextures(1, &mTextureId);
	}

	GLuint texture() const { return mTextureId; }
	const std::string& textureName() const { return mTextureName; }
	int w = 0,h = 0,n = 1;

	/**
	*  Load a file in memory and create an OpenGL texture.
	*  Returns a handle type (an std::unique_ptr) to the loaded pixels.
	*/
	uint8_t* load(const std::string& fileName) {
		if (mTextureId) {
			glDeleteTextures(1, &mTextureId);
			mTextureId = 0;
		}
		int force_channels = 0;

		uint8_t* textureData(stbi_load(fileName.c_str(), &w, &h, &n, force_channels));
		if (!textureData)
			throw std::invalid_argument("Could not load texture data from file " + fileName);
		glGenTextures(1, &mTextureId);
		glBindTexture(GL_TEXTURE_2D, mTextureId);
		GLint internalFormat;
		GLint format;
		switch (n) {
		case 1: internalFormat = GL_R8; format = GL_RED; break;
		case 2: internalFormat = GL_RG8; format = GL_RG; break;
		case 3: internalFormat = GL_RGB8; format = GL_RGB; break;
		case 4: internalFormat = GL_RGBA8; format = GL_RGBA; break;
		default: internalFormat = 0; format = 0; break;
		}
		glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, w, h, 0, format, GL_UNSIGNED_BYTE, textureData);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		return textureData;
	}
	void loadFromData(uint8_t* data) {
		if (mTextureId) {
			glDeleteTextures(1, &mTextureId);
			mTextureId = 0;
		}

		glGenTextures(1, &mTextureId);
		glBindTexture(GL_TEXTURE_2D, mTextureId);
		GLint internalFormat;
		GLint format;
		switch (n) {
		case 1: internalFormat = GL_R8; format = GL_RED; break;
		case 2: internalFormat = GL_RG8; format = GL_RG; break;
		case 3: internalFormat = GL_RGB8; format = GL_RGB; break;
		case 4: internalFormat = GL_RGBA8; format = GL_RGBA; break;
		default: internalFormat = 0; format = 0; break;
		}
		glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, w, h, 0, format, GL_UNSIGNED_BYTE, data);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	}

private:
	std::string mTextureName;
	GLuint mTextureId;
};

class Image {
public:
	Image() {
	}
	void setTex(GLTexture texture, uint8_t* data) {
		imgData.emplace_back(std::move(texture), data);
	}

	vector<pair<GLTexture, uint8_t*>> imgData;
};

class ExampleApplication : public nanogui::Screen {
public:
	ExampleApplication() : nanogui::Screen(Eigen::Vector2i(1024, 768), "NanoGUI Test") {
		using namespace nanogui;

		//////////////////////////////////Image Window ////////////////////////////////////////

		auto imageWindow = new Window(this, "ImageWindow");
		imageWindow->setPosition(Vector2i(768 - 200, 15));
		imageWindow->setLayout(new GroupLayout());
		GLTexture texture("start");
		uint8_t* data = texture.load("start.jpg");
		//imgDataList.emplace_back(std::move(texture), std::move(data));
		img = new Image();
		img->setTex(std::move(texture), data);

		auto imageView = new ImageView(imageWindow, img->imgData.back().first.texture());
		imageView->setGridThreshold(20);
		imageView->setPixelInfoThreshold(20);
		imageView->setPixelInfoCallback(
			[this, imageView](const Vector2i& index) -> pair<string, Color> {
			auto& imageData = imgDataList[0].second;
			auto& textureSize = imageView->imageSize();
			string stringData;
			uint16_t channelSum = 0;
			for (int i = 0; i != 4; ++i) {
				auto& channelData = imageData[4 * index.y()*textureSize.x() + 4 * index.x() + i];
				channelSum += channelData;
				stringData += (to_string(static_cast<int>(channelData)) + "\n");
			}
			float intensity = static_cast<float>(255 - (channelSum / 4)) / 255.0f;
			float colorScale = intensity > 0.5f ? (intensity + 1) / 2 : intensity / 2;
			Color textColor = Color(colorScale, 1.0f);
			return { stringData, textColor };
		});


		//////////////////////////////////File Load Window ////////////////////////////////////////

		Window *window = new Window(this, "Load File");
		window->setPosition(Vector2i(15, 15));
		window->setLayout(new GroupLayout());
		new Label(window, "File dialog", "sans-bold");
		Button *b = new Button(window, "Open");
		b->setCallback([this, imageView] {
			string filestr = file_dialog({}, false);
			cout << "File dialog result: " << filestr << endl;

			// load data from open file
			GLTexture texture(filestr);
			auto data = texture.load(filestr);
			img->imgData.pop_back();
			img->setTex(std::move(texture), data);

			// try to read data 
			cout << img->imgData.back().second[0] << endl;
			// bind texture imm.
			imageView->bindImage(img->imgData.back().first.texture());

		});
		b = new Button(window, "Save");
		b->setCallback([&] {
			cout << "File dialog result: " << file_dialog(
				{ {"png", "Portable Network Graphics"}, {"txt", "Text file"} }, true) << endl;
		});

		window = new Window(this, "Process Window");
		window->setPosition(Vector2i(15, 15));
		window->setLayout(new GroupLayout());
		Button *b1 = new Button(window, "Bind old Image!");
		b1->setCallback([this, imageView] {
			GLTexture ntexture("nstart");
			
			// Load imm. from mem data , not from file 
			// Load the last image to process 
			uint8_t* data = img->imgData.back().second;
			// do further process 
			/*for (int i = 0; i < 400*439*3; i+=3) {
				data[i] = 255;
				data[i+1] = 0;
				data[i+2] = 0;
			}*/

			//ut << img->imgData.back().first.w << endl;

			// Query the width of the OpenGL texture.

			int w = img->imgData.back().first.w;
			int h = img->imgData.back().first.h;
			int n = img->imgData.back().first.n;

			for (int i = 0; i < w / 2;i++) {
				for (int j = 0; j < h ; j++){
					int index = (i * h + j) * n;
					data[index] = 255;
					data[index + 1] = 0;
					data[index + 2] = 0;
					data[index + 3] = 0;
				}
			}

			// load data with glTexImage2D function 
			ntexture.w = w;
			ntexture.h = h;
			ntexture.n = n;
			ntexture.loadFromData(data);

			// update as pair!? just remember to do that , and it is reasonable
			img->setTex(std::move(ntexture), data);

			// call the Object of Image class -- it is the interface , 
			// we should always obtain data from that (not locally!)
			imageView->bindImage(img->imgData.back().first.texture());
		});



		performLayout();

		/* All NanoGUI widgets are initialized at this point. Now
		   create an OpenGL shader to draw the main window contents.

		   NanoGUI comes with a simple Eigen-based wrapper around OpenGL 3,
		   which eliminates most of the tedious and error-prone shader and
		   buffer object management.
		*/

		mShader.init(
			/* An identifying name */
			"a_simple_shader",

			/* Vertex shader */
			"#version 330\n"
			"uniform mat4 modelViewProj;\n"
			"in vec3 position;\n"
			"void main() {\n"
			"    gl_Position = modelViewProj * vec4(position, 1.0);\n"
			"}",

			/* Fragment shader */
			"#version 330\n"
			"out vec4 color;\n"
			"uniform float intensity;\n"
			"void main() {\n"
			"    color = vec4(vec3(intensity), 1.0);\n"
			"}"
		);

		MatrixXu indices(3, 2); /* Draw 2 triangles */
		indices.col(0) << 0, 1, 2;
		indices.col(1) << 2, 3, 0;

		MatrixXf positions(3, 4);
		positions.col(0) << -1, -1, 0;
		positions.col(1) << 1, -1, 0;
		positions.col(2) << 1, 1, 0;
		positions.col(3) << -1, 1, 0;

		mShader.bind();
		mShader.uploadIndices(indices);
		mShader.uploadAttrib("position", positions);
		mShader.setUniform("intensity", 0.5f);
	}

	~ExampleApplication() {
		mShader.free();
	}

	virtual bool keyboardEvent(int key, int scancode, int action, int modifiers) {
		if (Screen::keyboardEvent(key, scancode, action, modifiers))
			return true;
		if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {
			setVisible(false);
			return true;
		}
		return false;
	}

	virtual void draw(NVGcontext *ctx) {

		/* Draw the user interface */
		Screen::draw(ctx);
	}

	virtual void drawContents() {
		using namespace nanogui;

		/* Draw the window contents using OpenGL */
		mShader.bind();

		Matrix4f mvp;
		mvp.setIdentity();
		mvp.topLeftCorner<3, 3>() = Matrix3f(Eigen::AngleAxisf((float)glfwGetTime(), Vector3f::UnitZ())) * 0.25f;

		mvp.row(0) *= (float)mSize.y() / (float)mSize.x();

		mShader.setUniform("modelViewProj", mvp);
	}
private:
	nanogui::ProgressBar *mProgress;
	nanogui::GLShader mShader;

	vector<pair<GLTexture, GLTexture::handleType>> imgDataList;
	Image *img;
};

int main(int /* argc */, char ** /* argv */) {
	try {
		nanogui::init();

		/* scoped variables */ {
			nanogui::ref<ExampleApplication> app = new ExampleApplication();
			app->drawAll();
			app->setVisible(true);
			nanogui::mainloop();
		}

		nanogui::shutdown();
	}
	catch (const std::runtime_error &e) {
		std::string error_msg = std::string("Caught a fatal error: ") + std::string(e.what());
#if defined(_WIN32)
		MessageBoxA(nullptr, error_msg.c_str(), NULL, MB_ICONERROR | MB_OK);
#else
		std::cerr << error_msg << endl;
#endif
		return -1;
	}

	return 0;
}
