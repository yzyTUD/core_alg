
#include "TestMd2.h"
#include "tga.h"

#include "glut.h"
#include <glaux.h>// GLaux库的头文件
#include <math.h>
#include "stdio.h"
#include "stdlib.h"
#include "windows.h"
#include "mmsystem.h"                //导入声音头的文件
#pragma comment(lib,"winmm.lib")    //导入声音头的文件库

//#pragma comment( lib, "glu32.lib" )
#pragma comment(lib,"glaux.lib")
//#pragma comment( lib, "OpenGL32.lib" )
//#pragma comment(lib,"glut32.lib")

GLdouble flag = 0;
const int window_h = 800;
const int window_w = 800;
#define room_h  5.0f
#define size 10
float now_x = 10.0;
float now_y = 0;
float now_z = 10.0;
float rotate = 180.0;
float robotx = 10;
float robotz = 10;

GLuint g_texture[40];
void display();
//这个二维数组可以作为俯视图

int gallery[size][size] =
{
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },///->
    { 1, 0, 1, 0, 0, 0, 0, 1, 1, 1 },
    { 1, 0, 0, 1, 1, 0, 0, 1, 1, 1 },
    { 1, 0, 0, 1, 1, 0, 0, 1, 1, 1 },
    { 1, 0, 0, 0, 0, 0, 0, 1, 1, 1 },
    { 1, 0, 0, 0, 0, 0, 0, 1, 1, 1 },
    { 1, 0, 1, 1, 1, 1, 0, 0, 0, 0 },
    { 1, 0, 1, 1, 1, 1, 0, 0, 0, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }
};

void InitMaze()//初始化迷宫函数
{
    int i, j, temp;//定义
    for (i = 1; i <= size; i++)
    for (j = 1; j <= size; j++)
    {
        temp = rand() % 100 + 1;//随机产生1――100的随机数
        if (temp > 30)//如果随机数大于30
        {
            gallery[i - 1][j - 1] = 0;//当前数组值为0
        }
        else
        {
            gallery[i - 1][j - 1] = 1;//否则1
        }
    }
    gallery[0][0] = 0;//入口为0
    gallery[size - 1][size - 1] = 7;     //特殊的通路
    for (i = 1; i <= size; i++){
    for (j = 1; j <= size; j++){
        printf("%d ", gallery[i - 1][j - 1]);
    }printf("\n");}

    display();
}

bool LoadTexture(char *TexName, GLuint TexHandle)
{
    TGAImg Img;        // Image loader

    // Load our Texture
    if (Img.Load(TexName) != IMG_OK)
        return false;

    glBindTexture(GL_TEXTURE_2D, TexHandle); // Set our Tex handle as current

    // Create the texture
    if (Img.GetBPP() == 24)
        glTexImage2D(GL_TEXTURE_2D, 0, 3, Img.GetWidth(), Img.GetHeight(), 0, GL_RGB, GL_UNSIGNED_BYTE, Img.GetImg());
    else if (Img.GetBPP() == 32)
        glTexImage2D(GL_TEXTURE_2D, 0, 4, Img.GetWidth(), Img.GetHeight(), 0, GL_RGBA, GL_UNSIGNED_BYTE, Img.GetImg());
    else
        return false;

    // Specify filtering and edge actions
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

    return true;
}

void LoadModel()
{
    // load 3D information of the model knight.md2
    float minmax[6];
    //md2_model = md2_readModel("..\\data\\Knight.md2");
    //md2_getBoundingBox(md2_model, minmax);
    //model_center[0] = (minmax[0] + minmax[1]) / 2.0f;
    //model_center[1] = (minmax[2] + minmax[3]) / 2.0f;
    //model_center[2] = (minmax[4] + minmax[5]) / 2.0f;
    //model_radius = sqrt((minmax[0] - minmax[1]) * (minmax[0] - minmax[1]) +
    //               (minmax[2] - minmax[3]) * (minmax[2] - minmax[3]) +
    //               (minmax[4] - minmax[5]) * (minmax[4] - minmax[5])) / 2.0;

    // load 3D information of the model tris.md2
    md2_model_2 = md2_readModel("data/WalkMech.md2");
    md2_getBoundingBox(md2_model_2, minmax);
    model_center_2[0] = (minmax[0] + minmax[1]) / 2.0f;
    model_center_2[1] = (minmax[2] + minmax[3]) / 2.0f;
    model_center_2[2] = (minmax[4] + minmax[5]) / 2.0f;
    model_radius_2 = sqrt((minmax[0] - minmax[1]) * (minmax[0] - minmax[1]) +
        (minmax[2] - minmax[3]) * (minmax[2] - minmax[3]) +
        (minmax[4] - minmax[5]) * (minmax[4] - minmax[5])) / 2.0;

    LoadTexture("data/GenericMech.TGA", Decal_Texture);
}

AUX_RGBImageRec *LoadBMP(char * Filename) // 载入位图图象
{
    FILE *File = NULL;
    if (!Filename)
        return NULL;
    File = fopen(Filename, "r");
    if (File)
    {
        fclose(File);
        return auxDIBImageLoad(Filename);
    }
    return NULL;
}

// 载入位图(调用上面的代码)并转换成纹理
int LoadGLTextures(GLuint& unTexture, const char* chFileName)
{
    int Status = FALSE; // Status 状态指示器
    AUX_RGBImageRec *TextureImage;                                        //保存贴图数据的指针
    char* file_name = (char*)chFileName;
    if (TextureImage = LoadBMP(file_name))                    //载入贴图数据
    {
        Status = 1;
        glGenTextures(1, &unTexture);                                        // 创建一个纹理，unTexture
        glBindTexture(GL_TEXTURE_2D, unTexture);                            //绑定纹理，然后对该纹理区添加纹理数据
        // 生成纹理
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage->sizeX, TextureImage->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage->data);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);        //设置滤波为线性滤波
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);        //线性滤波
        if (TextureImage)                                                    //释放资源
        {
            if (TextureImage->data)
            {
                free(TextureImage->data);
            }
            free(TextureImage);
        }
    }
    return Status;
}

//这里将每面墙都画成了一个正方体，这样不论哪面墙都可以调用这个函数，只是有些图片我们看不见
void make_box(int k)
{
    glBindTexture(GL_TEXTURE_2D, g_texture[1]);        //使用贴图纹理
    glPushMatrix();
    glBegin(GL_QUADS);  //启用四边形带绘制模式绘制

    // 绘制前面，这里开始确定纹理坐标，然后是确定点的位置
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-room_h, -room_h, room_h);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(room_h, -room_h, room_h);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(room_h, room_h, room_h);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-room_h, room_h, room_h);

    // 绘制后面
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-room_h, -room_h, -room_h);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-room_h, room_h, -room_h);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(room_h, room_h, -room_h);
    glTexCoord2f(0.0f, 0.0f); glVertex3f(room_h, -room_h, -room_h);

    //// 上面
    //glTexCoord2f(0.0f, 1.0f); glVertex3f(-room_h,  room_h, -room_h);
    //glTexCoord2f(0.0f, 0.0f); glVertex3f(-room_h,  room_h,  room_h);
    //glTexCoord2f(1.0f, 0.0f); glVertex3f( room_h,  room_h,  room_h);
    //glTexCoord2f(1.0f, 1.0f); glVertex3f( room_h,  room_h, -room_h);

    //  //底面

    //  glTexCoord2f(1.0f, 1.0f); glVertex3f(-room_h, -room_h, -room_h);
    //  glTexCoord2f(0.0f, 1.0f); glVertex3f( room_h, -room_h, -room_h);
    //  glTexCoord2f(0.0f, 0.0f); glVertex3f( room_h, -room_h,  room_h);
    //  glTexCoord2f(1.0f, 0.0f); glVertex3f(-room_h, -room_h,  room_h);

    // 右面
    //glBindTexture(GL_TEXTURE_2D, g_texture[k+1]);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(room_h, -room_h, -room_h);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(room_h, room_h, -room_h);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(room_h, room_h, room_h);
    glTexCoord2f(0.0f, 0.0f); glVertex3f(room_h, -room_h, room_h);

    // 左面
    //glBindTexture(GL_TEXTURE_2D, g_texture[k+1]);
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-room_h, -room_h, -room_h);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-room_h, -room_h, room_h);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-room_h, room_h, room_h);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-room_h, room_h, -room_h);

    glEnd();

    glPopMatrix();
}

void PlayMusic()
{
    char buf[128];
    char str[128] = { 0 };
    int i = 0;

    MCI_OPEN_PARMS mciOpen;
    MCIERROR mciError;
    mciOpen.lpstrDeviceType = "mpegvideo";
    mciOpen.lpstrElementName = "vincent.wav";
    //使用 mciSendCommand 函数
    mciError = mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD)&mciOpen);
    if (mciError) {
        mciGetErrorString(mciError, buf, 128);
        //printf("发送 MCI_OPEN command failed:%s\n", buf);
        return;
    }
    UINT DeviceID = mciOpen.wDeviceID;
    MCI_PLAY_PARMS mciPlay;

    mciError = mciSendCommand(DeviceID, MCI_PLAY, 0, (DWORD)&mciPlay);
    if (mciError) {
        printf("send MCI_PLAY command failed\n");
        return;
    }
}

//在初始化的时候载入图片同时开始放音乐
void myinit()
{
    glClearColor(0.5f, 0.5f, 0.5f, 0.0f);
    glColor3f(1.0, 1.0, 1.0);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_TEXTURE_2D);
    //遍历的加载图片

    LoadGLTextures(g_texture[1], "wall.bmp");            //载入纹理贴图

    LoadGLTextures(g_texture[39], "100.bmp");
    LoadGLTextures(g_texture[38], "0.bmp");
    PlayMusic();

    //    PlaySound("vincent.wav", NULL, SND_FILENAME | SND_ASYNC | SND_LOOP);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(30.0, (double)window_w / (double)window_h, 1.0f, 100.0f);
    float fR = 360.0 - (rotate + 90.0f);
    gluLookAt(now_x, 0.0f, now_z, now_x + 15 * cosf(fR*3.141592f / 180.0f), -1, now_z + 15 * sinf(fR*3.141592f / 180.0f), 0.0f, 1.0f, 0.0f);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    robotx = now_x + 8 * cosf(fR*3.141592f / 180.0f);
    robotz = now_z + 8 * sinf(fR*3.141592f / 180.0f);

    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, Decal_Texture);
    //Tris

    glPushMatrix();
    glTranslatef(now_x + 8 * cosf(fR*3.141592f / 180.0f), -5, now_z + 8 * sinf(fR*3.141592f / 180.0f));
    glRotatef(rotate + 180, 0, 1, 0);
    glScalef(0.1, 0.1, 0.1);
    md2_drawModel(md2_model_2, current_frame, current_frame + 1, (float)current_subframe / 10);//LOOP_FRAME_NUM);
    glPopMatrix();

    Sleep(20);

    if (flag&& current_frame == MaxFrame){
        current_frame = 0;
        flag = false;
    }
    //tris
    if (current_frame < MaxFrame)
        current_frame++;

    /*if (current_frame == md2_model_2->header.numFrames - 1)
    current_frame = 0;*/

    //-----------------------------------------
    //画地面
    glPushMatrix();
    glBindTexture(GL_TEXTURE_2D, g_texture[39]);
    glBegin(GL_QUADS);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(0, -room_h, 0);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(20 * room_h, -room_h, -20 * room_h);
    glTexCoord2f(0.0f, 0.0f); glVertex3f(20 * room_h, -room_h, 20 * room_h);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-20 * room_h, -room_h, 20 * room_h);
    glEnd();
    glPopMatrix();

    //---------------------------------------------------
    ////画天空
    //glPushMatrix();
    //glBindTexture(GL_TEXTURE_2D, g_texture[38]);
    //glBegin(GL_QUADS);
    //glTexCoord2f(1.0f, 1.0f); glVertex3f(0, room_h, 0);
    //glTexCoord2f(0.0f, 1.0f); glVertex3f(16 * room_h, room_h, -16 * room_h);
    //glTexCoord2f(0.0f, 0.0f); glVertex3f(16 * room_h, room_h, 16 * room_h);
    //glTexCoord2f(1.0f, 0.0f); glVertex3f(-16 * room_h, room_h, 16 * room_h);
    //glEnd();
    //glPopMatrix();

    //画墙壁
    for (int i = 0; i<size; i++)
    {
        for (int j = 0; j<size; j++)
        {
            if (gallery[j][i] == 1)
            {
                glPushMatrix();
                glTranslatef((float)j*10.0f, 0.0f, (float)i*10.0f);
                int key = (size* i + j) % 32;
                make_box(key);
                glPopMatrix();
            }
        }
    }
    glutSwapBuffers();
    glutPostRedisplay();
}

void Autowalk(int src_x,int src_z,int dis_x,int dis_z,int flag){
    now_x = src_x;
    now_z = src_z;

    if (flag){
        while (now_z < dis_z){

            display();
            if (dis_z - src_z>0)
            {
                now_z++;
                rotate = 180;
            }
            else{
                now_z--;
                rotate = 0;
            }

            Sleep(50);
        }

        while (now_x < dis_x){

            display();
            if (dis_x - src_x>0){
                now_x++;
                rotate = 270;
            }
            else{
                now_x--;
                rotate = 90;
            }

            Sleep(50);
        }
    }
    else{
        while (now_x < dis_x){

            display();
            if (dis_x - src_x>0){
                now_x++;
                rotate = 270;
            }
            else{
                now_x--;
                rotate = 90;
            }

            Sleep(50);
        }
        while (now_z < dis_z){

            display();
            if (dis_z - src_z>0)
            {
                now_z++;
                rotate = 180;
            }
            else{
                now_z--;
                rotate = 0;
            }

            Sleep(50);
        }
    }
}

void KeyProcess(unsigned char key, int x, int y)
{
    switch (key)
    {
    case 27:  // 若按了esc
        exit(0);
        break;
    case 97:
        InitMaze();
        break;

    case 98:
        Autowalk(10,10,20,60,1);
        break;
    default:
        break;
    }
}

void specialkey(int key, int x, int y)
{
    float old_x = now_x;
    float old_z = now_z;
    float oldrx = robotx;
    float oldrz = robotz;
    float oldro = rotate;
    float fR = 360.0 - (rotate + 90.0f);

    //    前进
    if (key == GLUT_KEY_UP)  {
        float fR = 360.0 - (rotate + 90.0f);
        flag = true;
        now_x += 0.4f*cosf(fR * 3.141592f / 180.0f);
        now_z += 0.4f*sinf(fR * 3.141592f / 180.0f);
        printf("%f,%f,%f\n", now_x, now_y, now_z);
    }

    //    后退
    if (key == GLUT_KEY_DOWN)  {
        float fR = 360.0 - (rotate + 90.0f);
        now_x -= 0.4f*cosf(fR * 3.141592f / 180.0f);
        now_z -= 0.4f*sinf(fR * 3.141592f / 180.0f);
        printf("%f,%f,%f\n", robotx, now_y, robotx);
        return;
    }

    //左转
    if (key == GLUT_KEY_LEFT)  {
        rotate += 2;
        flag = true;
        robotx = now_x + 8 * cosf(fR*3.141592f / 180.0f);
        robotz = now_z + 8 * sinf(fR*3.141592f / 180.0f);
        printf("%f,%f,%f\n", robotx, now_y, robotx);
    }

    //右转
    if (key == GLUT_KEY_RIGHT)  {
        rotate -= 2;
        flag = true;
        robotx = now_x + 8 * cosf(fR*3.141592f / 180.0f);
        robotz = now_z + 8 * sinf(fR*3.141592f / 180.0f);
        printf("%f,%f,%f\n", robotx, now_y, robotx);
    }

    //判定是否会遇上墙壁，若遇上，则不允许
    for (int i = 0; i<size; i++)  {
        for (int j = 0; j<size; j++)  {
            if (gallery[j][i] == 1)  {
                float gallery_pos_x = (float)j*10.0f;
                float gallery_pos_z = (float)i*10.0f;
                if (robotx>gallery_pos_x - 6.5 && robotx<gallery_pos_x + 6.5 && robotz>gallery_pos_z - 6.5 && robotz<gallery_pos_z + 6.5) {
                    printf("请小心不要撞上墙壁！\n");
                    now_x = old_x;
                    now_z = old_z;
                    robotx = oldrx;
                    robotz = oldrz;
                    rotate = oldro;
                }
            }
        }
    }
    glutPostRedisplay();
}

int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(800, 800);
    glutCreateWindow("3D_MAZE");
    glutDisplayFunc(display);
    myinit();
    glutKeyboardFunc(KeyProcess);
    glutSpecialFunc(specialkey);
    LoadModel();
    glutMainLoop();

    return 0;
}

