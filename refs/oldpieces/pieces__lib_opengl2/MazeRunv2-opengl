
#include "TestMd2.h"
#include "tga.h"

#include "glut.h"
#include <GL\GLAUX.H>// GLaux库的头文件
#include <math.h>
#include "stdio.h"
#include "stdlib.h"
#include "windows.h"
#include "mmsystem.h"                //导入声音头的文件
#pragma comment(lib,"winmm.lib")    //导入声音头的文件库

int num;
struct
{
    int x, y, d;
}lj[100];//x,y分别为垂直和水平方向

//#pragma comment( lib, "glu32.lib" )
#pragma comment(lib,"glaux.lib")
//#pragma comment( lib, "OpenGL32.lib" )
//#pragma comment(lib,"glut32.lib")

GLdouble flag = 0;
const int window_h = 800;
const int window_w = 800;
#define room_h  5.0f
#define size 12
float now_x = 10.0;
float now_y = 0;
float now_z = 5;
float rotate = 180.0;
float robotx = 10;
float robotz = 10;
float jiao=10;
float jin = 10;
GLuint g_texture[40];
void display();

//这个二维数组可以作为俯视图
void AutoGO(int migong[12][12], int end);
int maze[12][12] = //设置迷宫，最外围1为墙 里边0为可走路径 1为障碍
{
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },///->y
    { 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1 },
    { 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1 },
    { 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1 },
    { 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1 },
    { 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1 },
    { 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1 },
    { 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1 },
    { 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1 },
    { 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1 }

};

int maze2d[12][12] = //设置迷宫，最外围1为墙 里边0为可走路径 1为障碍
{
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },///->y
    { 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1 },
    { 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1 },
    { 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1 },
    { 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1 },
    { 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1 },
    { 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1 },
    { 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1 },
    { 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1 },
    { 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1 }

};

void specialkey(int key, int x, int y);
void KeyProcess(unsigned char key, int x, int y);
void InitMaze()//初始化迷宫函数
{
    int i, j, temp;//定义
    for (i = 1; i < size-1; i++)
    for (j = 1; j < size-1; j++)
    {
        temp = rand() % 100 + 1;//随机产生1――100的随机数
        if (temp > 30)//如果随机数大于30
        {
            maze[i ][j ] = 0;//当前数组值为0
        }
        else
        {
            maze[i ][j ] = 1;//否则1
        }
    }
    maze[1][1] = 0;//入口为0
    //maze[size - 1][size - 1] = 1;     //特殊的通路
    for (i = 1; i <= size; i++){
    for (j = 1; j <= size; j++){
        printf("%d ", maze[i - 1][j - 1]);
    }printf("\n");}

    display();
}

bool LoadTexture(char *TexName, GLuint TexHandle)
{
    TGAImg Img;        // Image loader

    // Load our Texture
    if (Img.Load(TexName) != IMG_OK)
        return false;

    glBindTexture(GL_TEXTURE_2D, TexHandle); // Set our Tex handle as current

    // Create the texture
    if (Img.GetBPP() == 24)
        glTexImage2D(GL_TEXTURE_2D, 0, 3, Img.GetWidth(), Img.GetHeight(), 0, GL_RGB, GL_UNSIGNED_BYTE, Img.GetImg());
    else if (Img.GetBPP() == 32)
        glTexImage2D(GL_TEXTURE_2D, 0, 4, Img.GetWidth(), Img.GetHeight(), 0, GL_RGBA, GL_UNSIGNED_BYTE, Img.GetImg());
    else
        return false;

    // Specify filtering and edge actions
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

    return true;
}

void LoadModel()
{
    // load 3D information of the model knight.md2
    float minmax[6];
    //md2_model = md2_readModel("..\\data\\Knight.md2");
    //md2_getBoundingBox(md2_model, minmax);
    //model_center[0] = (minmax[0] + minmax[1]) / 2.0f;
    //model_center[1] = (minmax[2] + minmax[3]) / 2.0f;
    //model_center[2] = (minmax[4] + minmax[5]) / 2.0f;
    //model_radius = sqrt((minmax[0] - minmax[1]) * (minmax[0] - minmax[1]) +
    //               (minmax[2] - minmax[3]) * (minmax[2] - minmax[3]) +
    //               (minmax[4] - minmax[5]) * (minmax[4] - minmax[5])) / 2.0;

    // load 3D information of the model tris.md2
    md2_model_2 = md2_readModel("data/WalkMech.md2");
    md2_getBoundingBox(md2_model_2, minmax);
    model_center_2[0] = (minmax[0] + minmax[1]) / 2.0f;
    model_center_2[1] = (minmax[2] + minmax[3]) / 2.0f;
    model_center_2[2] = (minmax[4] + minmax[5]) / 2.0f;
    model_radius_2 = sqrt((minmax[0] - minmax[1]) * (minmax[0] - minmax[1]) +
        (minmax[2] - minmax[3]) * (minmax[2] - minmax[3]) +
        (minmax[4] - minmax[5]) * (minmax[4] - minmax[5])) / 2.0;

    LoadTexture("data/GenericMech.TGA", Decal_Texture);
}

AUX_RGBImageRec *LoadBMP(char * Filename) // 载入位图图象
{
    FILE *File = NULL;
    if (!Filename)
        return NULL;
    File = fopen(Filename, "r");
    if (File)
    {
        fclose(File);
        return auxDIBImageLoad(Filename);
    }
    return NULL;
}

// 载入位图(调用上面的代码)并转换成纹理
int LoadGLTextures(GLuint& unTexture, const char* chFileName)
{
    int Status = FALSE; // Status 状态指示器
    AUX_RGBImageRec *TextureImage;                                        //保存贴图数据的指针
    char* file_name = (char*)chFileName;
    if (TextureImage = LoadBMP(file_name))                    //载入贴图数据
    {
        Status = 1;
        glGenTextures(1, &unTexture);                                        // 创建一个纹理，unTexture
        glBindTexture(GL_TEXTURE_2D, unTexture);                            //绑定纹理，然后对该纹理区添加纹理数据
        // 生成纹理
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage->sizeX, TextureImage->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage->data);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);        //设置滤波为线性滤波
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);        //线性滤波
        if (TextureImage)                                                    //释放资源
        {
            if (TextureImage->data)
            {
                free(TextureImage->data);
            }
            free(TextureImage);
        }
    }
    return Status;
}

//这里将每面墙都画成了一个正方体，这样不论哪面墙都可以调用这个函数，只是有些图片我们看不见
void make_box(int k)
{
    glBindTexture(GL_TEXTURE_2D, g_texture[1]);        //使用贴图纹理
    glPushMatrix();
    glBegin(GL_QUADS);  //启用四边形带绘制模式绘制

    // 绘制前面，这里开始确定纹理坐标，然后是确定点的位置
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-room_h, -room_h, room_h);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(room_h, -room_h, room_h);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(room_h, room_h, room_h);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-room_h, room_h, room_h);

    // 绘制后面
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-room_h, -room_h, -room_h);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-room_h, room_h, -room_h);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(room_h, room_h, -room_h);
    glTexCoord2f(0.0f, 0.0f); glVertex3f(room_h, -room_h, -room_h);

    //// 上面
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-room_h,  room_h, -room_h);
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-room_h,  room_h,  room_h);
    glTexCoord2f(1.0f, 0.0f); glVertex3f( room_h,  room_h,  room_h);
    glTexCoord2f(1.0f, 1.0f); glVertex3f( room_h,  room_h, -room_h);

    //  //底面

    //  glTexCoord2f(1.0f, 1.0f); glVertex3f(-room_h, -room_h, -room_h);
    //  glTexCoord2f(0.0f, 1.0f); glVertex3f( room_h, -room_h, -room_h);
    //  glTexCoord2f(0.0f, 0.0f); glVertex3f( room_h, -room_h,  room_h);
    //  glTexCoord2f(1.0f, 0.0f); glVertex3f(-room_h, -room_h,  room_h);

    // 右面
    //glBindTexture(GL_TEXTURE_2D, g_texture[k+1]);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(room_h, -room_h, -room_h);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(room_h, room_h, -room_h);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(room_h, room_h, room_h);
    glTexCoord2f(0.0f, 0.0f); glVertex3f(room_h, -room_h, room_h);

    // 左面
    //glBindTexture(GL_TEXTURE_2D, g_texture[k+1]);
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-room_h, -room_h, -room_h);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-room_h, -room_h, room_h);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-room_h, room_h, room_h);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-room_h, room_h, -room_h);

    glEnd();

    glPopMatrix();
}

void PlayMusic()
{
    char buf[128];
    char str[128] = { 0 };
    int i = 0;

    MCI_OPEN_PARMS mciOpen;
    MCIERROR mciError;
    mciOpen.lpstrDeviceType = "mpegvideo";
    mciOpen.lpstrElementName = "vincent.wav";
    //使用 mciSendCommand 函数
    mciError = mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD)&mciOpen);
    if (mciError) {
        mciGetErrorString(mciError, buf, 128);
        //printf("发送 MCI_OPEN command failed:%s\n", buf);
        return;
    }
    UINT DeviceID = mciOpen.wDeviceID;
    MCI_PLAY_PARMS mciPlay;

    mciError = mciSendCommand(DeviceID, MCI_PLAY, 0, (DWORD)&mciPlay);
    if (mciError) {
        printf("send MCI_PLAY command failed\n");
        return;
    }
}

//在初始化的时候载入图片同时开始放音乐
void myinit()
{
    glClearColor(0.5f, 0.5f, 0.5f, 0.0f);
    glColor3f(1.0, 1.0, 1.0);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_TEXTURE_2D);
    LoadGLTextures(g_texture[1], "wall.bmp");            //载入纹理贴图
    LoadGLTextures(g_texture[2], "2.bmp");
    LoadGLTextures(g_texture[39], "100.bmp");
    LoadGLTextures(g_texture[38], "0.bmp");
    LoadModel();
    //PlayMusic();
    //    PlaySound("vincent.wav", NULL, SND_FILENAME | SND_ASYNC | SND_LOOP);
}

void myinit2()
{
    glClearColor(0.5f, 0.5f, 0.5f, 0.0f);
    glColor3f(1.0, 1.0, 1.0);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_TEXTURE_2D);
    LoadGLTextures(g_texture[1], "wall.bmp");            //载入纹理贴图
    LoadGLTextures(g_texture[2], "2.bmp");
    LoadGLTextures(g_texture[39], "100.bmp");
    LoadGLTextures(g_texture[38], "0.bmp");
    LoadModel();
    //PlayMusic();
    //    PlaySound("vincent.wav", NULL, SND_FILENAME | SND_ASYNC | SND_LOOP);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(30.0, (double)window_w / (double)window_h, 1.0f, 800);
    float fR = 360.0 - (rotate + 90.0f);
    robotx = now_x + 5 * cosf(fR*3.141592f / 180.0f);
    robotz = now_z + 5 * sinf(fR*3.141592f / 180.0f);
    float lookx = now_x - jin * cosf(fR*3.141592f / 180.0f);
    float lookz = now_z - jin * sinf(fR*3.141592f / 180.0f);

    float lookpx = now_x + 10 * cosf(fR*3.141592f / 180.0f);
    float lookpz = now_z + 10 * sinf(fR*3.141592f / 180.0f);

    gluLookAt(lookx, jiao, lookz, lookpx, -0.5, lookpz, 0.0f, 1.0f, 0.0f);
    //10 10 0   10  -0.5 20
    //printf("x z %f %f\n", now_x - jin * cosf(fR*3.141592f / 180.0f), now_z - jin * sinf(fR*3.141592f / 180.0f));

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, Decal_Texture);
    //Tris

    if ((abs(now_x + 5 * cosf(fR*3.141592f / 180.0f) - 11 * 10)<10) && (abs(now_z + 5 * sinf(fR*3.141592f / 180.0f) - 11 * 10)<10)){
        printf("YOU WIN!");
    }

    glPushMatrix();
    glTranslatef(now_x + 5 * cosf(fR*3.141592f / 180.0f), -5, now_z + 5 * sinf(fR*3.141592f / 180.0f));
    glRotatef(rotate + 180, 0, 1, 0);
    glScalef(0.1, 0.1, 0.1);
    md2_drawModel(md2_model_2, current_frame, current_frame + 1, (float)current_subframe / 10);//LOOP_FRAME_NUM);
    glPopMatrix();

    Sleep(20);

    if (flag&& current_frame == MaxFrame){
        current_frame = 0;
        flag = false;
    }
    //tris
    if (current_frame < MaxFrame)
        current_frame++;

    /*if (current_frame == md2_model_2->header.numFrames - 1)
    current_frame = 0;*/

    //-----------------------------------------
    //画地面
    glPushMatrix();
    glBindTexture(GL_TEXTURE_2D, g_texture[39]);
    glBegin(GL_QUADS);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-room_h, -room_h, -room_h);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-room_h, -room_h, 24 * room_h - room_h);
    glTexCoord2f(0.0f, 0.0f); glVertex3f(24 * room_h - room_h, -room_h, 24 * room_h - room_h);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(24 * room_h - room_h, -room_h, -room_h);
    glEnd();
    glPopMatrix();

    //---------------------------------------------------
    ////画天空
    //glPushMatrix();
    //glBindTexture(GL_TEXTURE_2D, g_texture[38]);
    //glBegin(GL_QUADS);
    //glTexCoord2f(1.0f, 1.0f); glVertex3f(0, room_h, 0);
    //glTexCoord2f(0.0f, 1.0f); glVertex3f(16 * room_h, room_h, -16 * room_h);
    //glTexCoord2f(0.0f, 0.0f); glVertex3f(16 * room_h, room_h, 16 * room_h);
    //glTexCoord2f(1.0f, 0.0f); glVertex3f(-16 * room_h, room_h, 16 * room_h);
    //glEnd();
    //glPopMatrix();

    //画墙壁
    for (int i = 0; i<size; i++)
    {
        for (int j = 0; j<size; j++)
        {
            if (maze[j][i] == 1)
            {
                glPushMatrix();
                glTranslatef((float)j*10.0f, 0.0f, (float)i*10.0f);
                int key = (size* i + j) % 32;
                make_box(key);
                glPopMatrix();
            }
        }
    }

    glutSwapBuffers();
    glutPostRedisplay();
}

void Autowalk(int src_x,int src_z,int dis_x,int dis_z,int f){
    now_x = src_x;
    now_z = src_z;

    if (now_z < dis_z){//z方向走

        if (dis_z - src_z>0){

            switch ((int)rotate){
            case 90:
                while (rotate<180){
                    rotate++;
                    Sleep(10);
                    display();

                }
                break;
            case -90:
                while (rotate>-180){
                    rotate--;
                    Sleep(10);
                    display();
                }
                break;
            }
            rotate = 180;

        }
        else{
            switch ((int)rotate){
            case 90:
                while (rotate>0){
                    rotate--;
                    Sleep(10);
                    display();
                }
                break;
            case -90:
                while (rotate<0){
                    rotate++;
                    Sleep(10);
                    display();
                }
                break;
            }
            rotate = 0;
        }
    }

        while (now_z < dis_z){

            display();
                now_z++;
                flag = true;
            Sleep(50);
        }

        while (now_z > dis_z){

            display();
                now_z--;
                flag = true;
            Sleep(50);
        }

        ////////////////////////////////////////////////////////

        if (now_x < dis_x){//x方向走

            if (dis_x - src_x>0){
                switch ((int)rotate){
                case 180:
                    rotate = -180;
                    while (rotate<-90){
                        rotate++;
                        Sleep(10);
                        display();
                    }
                    break;
                case 0:
                    while (rotate>-90){
                        rotate--;
                        Sleep(10);
                        display();
                    }
                    break;
                }
                rotate = -90;

            }
            else{
                switch ((int)rotate){
                case 180:
                    while (rotate>90){
                        rotate--;
                        Sleep(10);
                        display();
                    }
                    break;
                case 0:
                    while (rotate<90){
                        rotate++;
                        Sleep(10);
                        display();
                    }
                    break;
                }
                rotate = 90;
            }
        }

        while (now_x < dis_x){

            display();
                now_x++;
                flag = true;
            Sleep(50);
        }

        while (now_x >dis_x){

            display();
                now_x--;
                flag = true;
            Sleep(50);
        }
}

void KeyProcess(unsigned char key, int x, int y)
{
    switch (key)
    {
    case 27:  // 若按了esc
        exit(0);
        break;
    case 97:
        InitMaze();
        break;

    case 98:
        rotate = 180;
        AutoGO(maze, 10);
        break;

    case 99:
        jiao += 1;
        printf("\n角度：%f",jiao);
        display();
        break;
    case 100:
        jiao -= 1;
        display();
        break;
    case 101:
        jin += 1;
        printf("\n距离：%f", jin);
        display();
        break;
    case 102:
        jin -= 1;
        display();
        break;
    case 103:
        jin=209;
        jiao = 247;
        display();
        break;
    default:
        break;
    }
}

void AutoGO(int migong[12][12], int end)
{
    int top = 0, x, y, d, find;//d为设置方向，上下左右。find为设置找不找得到路。top数组模拟堆栈
    lj[top].x = 1;
    lj[top].y = 1;
    migong[1][1] = -1;
    find = 0; d = -1;

    while (top>-1){
        if (lj[top].x == 11 && lj[top].y == 10)//设置递归结束条件
        {
            printf("迷宫路径如下：\n");
            printf("start->");
            for (x = 0; x <= top; x++)
            {
                printf("(%d,%d)-> ", lj[x].x, lj[x].y);//把找到的路径输出
                num++;
                /*if (num % 8 == 0)
                printf("\n");*/
            }
            printf("->end!\n");
            break;
        }

        //Sleep(1000);
        for (int i = 0; i < 12; i++){
            for (int j = 0; j < 12; j++){
                printf("%2d ", migong[i][j]);
            }
            printf("\n");
        }printf("\n");

        while (d<4 && find == 0){
            d++;
            switch (d){
            case 0:x = lj[top].x - 1; y = lj[top].y;  break;//方向为上
            case 1:x = lj[top].x;   y = lj[top].y + 1; break;//方向为右
            case 3:x = lj[top].x;   y = lj[top].y - 1; break;//方向为左
            case 2:x = lj[top].x + 1; y = lj[top].y; break; //方向为下
            }
            if (migong[x][y] == 0)
                find = 1;
        }

        if (find == 1){     //判断是否可行
            Autowalk(lj[top].x*10, lj[top].y*10, x*10, y*10, 1);

            lj[top].d = d;
            top++;
            lj[top].x = x;
            lj[top].y = y;
            d = -1; find = 0;     //重新调整方向
            migong[x][y] = -1;
        }
        else{
            migong[lj[top].x][lj[top].y] = 0;//重置回0
            int m = lj[top].x;
            int n = lj[top].y;
            top--; d = lj[top].d; //找不到的话退栈

            Autowalk(m*10,n*10,lj[top].x * 10, lj[top].y * 10, 1);
        }
    }
}

void specialkey(int key, int x, int y)
{
    float old_x = now_x;
    float old_z = now_z;
    float oldrx = robotx;
    float oldrz = robotz;
    float oldro = rotate;
    float fR = 360.0 - (rotate + 90.0f);
    int tui=false;
    //    前进
    if (key == GLUT_KEY_UP)  {
        float fR = 360.0 - (rotate + 90.0f);
        flag = true;
        now_x += 0.4f*cosf(fR * 3.141592f / 180.0f);
        now_z += 0.4f*sinf(fR * 3.141592f / 180.0f);
        printf("%f,%f,%f\n", now_x, now_y, now_z);
    }

    //    后退
    if (key == GLUT_KEY_DOWN)  {
        float fR = 360.0 - (rotate + 90.0f);
        flag = true;
        now_x -= 0.4f*cosf(fR * 3.141592f / 180.0f);
        now_z -= 0.4f*sinf(fR * 3.141592f / 180.0f);
        printf("%f,%f,%f\n", robotx, now_y, robotx);
         tui= true;
    }

    //左转
    if (key == GLUT_KEY_LEFT)  {
        rotate += 2;
        flag = true;
        robotx = now_x + 8 * cosf(fR*3.141592f / 180.0f);
        robotz = now_z + 8 * sinf(fR*3.141592f / 180.0f);
        printf("%f,%f,%f\n", robotx, now_y, robotx);
    }

    //右转
    if (key == GLUT_KEY_RIGHT)  {
        rotate -= 2;
        flag = true;
        robotx = now_x + 8 * cosf(fR*3.141592f / 180.0f);
        robotz = now_z + 8 * sinf(fR*3.141592f / 180.0f);
        printf("%f,%f,%f\n", robotx, now_y, robotx);
    }

    //判定是否会遇上墙壁，若遇上，则不允许
    for (int i = 0; i<size; i++)  {
        for (int j = 0; j<size; j++)  {
            if (maze[j][i] == 1)  {
                float maze_pos_x = (float)j*10.0f;
                float maze_pos_z = (float)i*10.0f;
                if (abs(robotx - maze_pos_x) < 8 && abs(robotz - maze_pos_z)<8) {
                    printf("不要撞上墙壁！\n");

                    if (tui){
                        tui = false;
                        float fR = 360.0 - (rotate + 90.0f);
                        now_x += 1.5 * cosf(fR * 3.141592f / 180.0f);
                        now_z += 1.5 * sinf(fR * 3.141592f / 180.0f);
                        //now_x = old_x;
                        //now_z = old_z;
                        robotx += 1.5 * cosf(fR * 3.141592f / 180.0f);
                        robotz += 1.5 * sinf(fR * 3.141592f / 180.0f);
                        rotate = oldro;
                    }
                    else{
                        float fR = 360.0 - (rotate + 90.0f);
                        now_x -= 1.5 * cosf(fR * 3.141592f / 180.0f);
                        now_z -= 1.5 * sinf(fR * 3.141592f / 180.0f);
                        /*now_x = old_x;
                        now_z = old_z;*/
                        robotx -= 1.5 * cosf(fR * 3.141592f / 180.0f);
                        robotz -= 1.5 * sinf(fR * 3.141592f / 180.0f);
                        rotate = oldro;
                    }

                }
            }
        }
    }
    glutPostRedisplay();
}
void dissubwin(){

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(30.0, (double)window_w / (double)window_h, 1.0f, 1000);
    float fR = 360.0 - (rotate + 90.0f);
    robotx = now_x + 5 * cosf(fR*3.141592f / 180.0f)+5;
    robotz = now_z + 5 * sinf(fR*3.141592f / 180.0f)+5;

    maze2d[(int)(robotx / 10.0)][(int)(robotz / 10.0)] = -1;

    /*for (int i = 0; i < 12; i++){
        for (int j = 0; j < 12; j++){
            printf("%d ", maze2d[i][j]);
        }
        printf("\n");
    }printf("\n");*/

    gluLookAt(55 ,200 ,54 , 55 ,-0.5, 55, 0.0f, 1.0f, 0.0f);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, Decal_Texture);
    //Tris
    glPushMatrix();
    glTranslatef(now_x + 5 * cosf(fR*3.141592f / 180.0f), -5, now_z + 5 * sinf(fR*3.141592f / 180.0f));
    glRotatef(rotate + 180, 0, 1, 0);
    glScalef(0.1, 0.1, 0.1);
    md2_drawModel(md2_model_2, current_frame, current_frame + 1, (float)current_subframe / 10);//LOOP_FRAME_NUM);
    glPopMatrix();
    Sleep(20);
    if (flag&& current_frame == MaxFrame){
        current_frame = 0;
        flag = false;
    }
    //tris
    if (current_frame < MaxFrame)
        current_frame++;
    //-----------------------------------------
    //画地面
    glPushMatrix();
    glBindTexture(GL_TEXTURE_2D, g_texture[39]);
    glBegin(GL_QUADS);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-room_h, -room_h, -room_h);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-room_h, -room_h, 24 * room_h - room_h);
    glTexCoord2f(0.0f, 0.0f); glVertex3f(24 * room_h - room_h, -room_h, 24 * room_h - room_h);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(24 * room_h - room_h, -room_h, -room_h);
    glEnd();
    glPopMatrix();
    //画墙壁
    for (int i = 0; i<size; i++)
    {
        for (int j = 0; j<size; j++)
        {
            if (maze[j][i] == 1)
            {
                glPushMatrix();
                glTranslatef((float)j*10.0f, 0.0f, (float)i*10.0f);
                int key = (size* i + j) % 32;
                make_box(key);
                glPopMatrix();
            }
        }
    }
    for (int i = 0; i < size; i++)  {
        for (int j = 0; j < size; j++)  {
            if (maze2d[i][j] == -1)  {
                float maze_pos_x = (float)i*10.0f;
                float maze_pos_z = (float)j*10.0f;
                glPushMatrix();
                glBindTexture(GL_TEXTURE_2D, g_texture[2]);
                glBegin(GL_QUADS);
                glTexCoord2f(1.0f, 1.0f); glVertex3f(maze_pos_x - room_h, -room_h + 1, maze_pos_z - room_h);
                glTexCoord2f(0.0f, 1.0f); glVertex3f(maze_pos_x + room_h, -room_h + 1, maze_pos_z - room_h);
                glTexCoord2f(0.0f, 0.0f); glVertex3f(maze_pos_x + room_h, -room_h + 1, maze_pos_z + room_h);
                glTexCoord2f(1.0f, 0.0f); glVertex3f(maze_pos_x - room_h, -room_h + 1, maze_pos_z + room_h);
                glEnd();
                glPopMatrix();
            }
        }
    }

    glutSwapBuffers();
    glutPostRedisplay();
}

int alpha = 0;

void handleResize(int w, int h) {
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, 30, 0, 30, -14, 14);
}

void drawScene() {

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    float bk = 2.0 / 13;

    for (int i = 0; i<12; i++){
        for (int j = 0; j<12; j++){
            glPushMatrix();
            glTranslatef(28-(i + 1)*(2 + bk),(j + 1)*(2 + bk), 0);
            glBegin(GL_QUADS);
            if (maze[i][j] == 1){
                glColor3f(0, 1, 0);
            }
            else{
                glColor3f(1, 1, 1);
            }
            glVertex3f(0, 0, 0);
            glVertex3f(2, 0, 0);
            glVertex3f(2, 2, 0);
            glVertex3f(0, 2, 0);
            glEnd();
            glPopMatrix();
        }
    }

    glutSwapBuffers();

}

void mouseCB(int button, int state, int x, int y)
{

    if (button == GLUT_LEFT_BUTTON)
    {
        if (state == GLUT_DOWN)
        {

            if (x - 28.5>0){
                if (maze[13-(int)(x / 28.5) - 1][13 - (int)(y / 28.5) - 1] == 1)
                    maze[13-(int)(x / 28.5) - 1][13 - (int)(y / 28.5) - 1] = 0;
                else
                    maze[13-(int)(x / 28.5) - 1][13 - (int)(y / 28.5) - 1] = 1;

            }

            //mouseLeftDown = true;
        }
        else if (state == GLUT_UP)
            drawScene();
        //mouseLeftDown = false;
    }

    else if (button == GLUT_RIGHT_BUTTON)
    {
        if (state == GLUT_DOWN)
        {
            //mouseRightDown = true;
        }
        // else if(state == GLUT_UP)
        //mouseRightDown = false;
    }
}

void topMenu(int id)
{
    switch (id)
    {

    case 0:

    case 1:
        glutInitWindowSize(400, 400);
        glutCreateWindow("地图编辑器");
        glutMouseFunc(mouseCB);
        glutDisplayFunc(drawScene);
        glutReshapeFunc(handleResize);
        break;
    }
}

int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(600, 600);

    glutCreateWindow("3D_MAZE");
    glutDisplayFunc(display);
    glutKeyboardFunc(KeyProcess);
    glutSpecialFunc(specialkey);
    myinit();
    /*glutCreateMenu(topMenu);
    glutAddMenuEntry("地图编辑器", 1);
    glutAttachMenu(GLUT_RIGHT_BUTTON);*/

    //glutCreateSubWindow(mw, 380, 10, 200, 200);
    glutCreateWindow("2D_MAZE");
    glutDisplayFunc(dissubwin);
    myinit2();

    glutInitWindowSize(400, 400);
    glutCreateWindow("地图编辑器");
    glutMouseFunc(mouseCB);
    glutDisplayFunc(drawScene);
    glutReshapeFunc(handleResize);

    glutMainLoop();

    return 0;
}

