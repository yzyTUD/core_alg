
#include <stdio.h>
#include <malloc.h>
#define MaxVertexNum 100 /*最大顶点数设为100*/
typedef char VertexType; /*顶点类型设为字符型*/
typedef int EdgeType; /*边的权值设为整型*/
bool visited[MaxVertexNum];

typedef struct {
    VertexType vexs[MaxVertexNum];                /*顶点表*/
    EdgeType edges[MaxVertexNum][MaxVertexNum]; /*邻接矩阵，即边表*/
    int n, e;                                    /*顶点数和边数*/
}Mgragh;

void CreateMGraph(Mgragh *G)
{
    G->n = 4;

    G->vexs[0] = 'A';
    G->vexs[1] = 'B';
    G->vexs[2] = 'C';
    G->vexs[3] = 'D';
    for (int i = 0; i < G->n;i++)
        for (int j = 0; j < G->n; j++)
            G->edges[i][j] = 0;
    G->edges[0][1] = 1;
    G->edges[0][2] = 1;
    G->edges[1][3] = 1;

}/*CreateMGraph*/

void show(Mgragh *G){
    int i, j;
    for (i = 0; i < G->n; i++){
        for (j = 0; j < G->n; j++)
            printf("%d ", G->edges[i][j]);
        printf("\n");
    }
}

void DFSAL(Mgragh *G, int m)
{/*以Vi 为出发点对邻接表存储的图G 进行DFS 搜索*/
    printf("visit:%c\n", G->vexs[m]);
    visited[m] = true;
    for (int i = 0; i < G->n; i++){
        if (G->edges[i][m] == 1 && visited[i] == false){
            DFSAL(G, i);
        }
        if (G->edges[m][i] == 1 && visited[i] == false){
            DFSAL(G, i);
        }
    }
}/*DFSAL*/

void DFSTraverseAL(Mgragh *G)
{/*深度优先遍历以邻接表存储的图G*/

    for (int i = 0; i<G->n; i++)
        visited[i] = false; /*标志向量初始化*/

    DFSAL(G, 0); /*vi 未访问过，从vi 开始DFS 搜索*/
}/*DFSTraveseAL*/

int main(){

    Mgragh * m = (Mgragh*)malloc(sizeof(Mgragh));
    CreateMGraph(m);
    show(m);
    DFSTraverseAL(m);

    getchar();
    getchar();
    return 0;
}

/*
    3,2
    A B C
    0,1 1,2

*/

============================================================================================================

//用邻接矩阵表示的图的深度优先搜索和广度优先搜索
//我这个函数是以无向图为基础
//DFS(深度优先搜索),采用的方法是递归
//BFS(广度优先搜索),采用的是队列的方案，本来c++中是有队列queue这个类的，不过考虑到你们应该是c版本的，我简单写了一个循环队列

//2010年1月6日13:34:49
//writed by zjd

#include<stdio.h>
#include<stdlib.h>//头文件包含malloc函数，用来申请内存空间

const int maxnum = 100;//设置邻接矩阵的最大阶数

//图的邻接矩阵表示结构定义
typedef struct{
    int v[maxnum];//图的顶点信息
    int e[maxnum][maxnum];//图的边信息
    int vNum;//顶点个数
    int eNum;//边的个数
}graph;

int visited[maxnum];//标记这个顶点是否被访问过，0表示没有，1表示已经被访问过

//循环队列
typedef struct{
    int front;//队列头
    int rear;//队列尾
    int count;//队列技术
    int q[maxnum];//数组表示队列
}cirqueue;

void createGraph(graph *g);//建立图g的函数
void dfs(graph *g, int i);//对以邻接矩阵表示的图，以序号为i的顶点为出发点进行深度优先搜索
void DFS(graph *g);//深度优先搜索
void bfs(graph *g, int i);//对以邻接矩阵表示的图，以序号为i的顶点为出发点进行广度优先搜索
void BFS(graph *g);//广度优先搜索

int main(){
    //以下两个语句用来建立用邻接矩阵表示的图
    graph g;
    createGraph(&g);//创建图
    printf("深度优先搜索的结果：\n");
    DFS(&g);
    printf("广度优先搜索的结果：\n");
    BFS(&g);

    getchar();
    getchar();
    return 0;
}

void createGraph(graph *G){
    G->vNum = 4;

    G->v[0] = 'A';
    G->v[1] = 'B';
    G->v[2] = 'C';
    G->v[3] = 'D';
    for (int i = 0; i < G->vNum; i++)
        for (int j = 0; j < G->vNum; j++)
            G->e[i][j] = 0;
    G->e[0][1] = 1;
    G->e[0][2] = 1;
    G->e[1][3] = 1;

}

void dfs(graph *g, int i){
    printf("%d\n", i);//i已经被访问
    visited[i] = 1;//标记i边已经被访问
    for (int j = 0; j<g->vNum; j++){//对与i点与全部节点进行扫描
        if (g->e[i][j] != 0 && visited[j] == 0){//假如j点与i点相连，并且j点还没有被访问过
            dfs(g, j);//递归方法，对j点进行深度优先搜索
        }
    }
}

void DFS(graph *g){
    int i;
    //首先把所有点都设置成没有访问过
    for (i = 0; i<g->vNum; i++){
        visited[i] = 0;
    }
    //深度优先搜索
    for (i = 0; i<g->vNum; i++){
        if (visited[i] == 0){//假如i点没有被访问过
            dfs(g, i);//对以邻接矩阵表示的图，以序号为i的顶点为出发点进行深度优先搜索
        }
    }
    printf("\n");
}

void bfs(graph *g, int i){
    int j, k;
    printf("%d\n", i);//i已经被访问
    visited[i] = 1;//标记i边已经被访问
    cirqueue *p = (cirqueue*)malloc(sizeof(cirqueue));//申请一个对队列
    p->front = p->rear = p->count = 0;//表示队列为空
    //以下三行代码使得i进入队列
    p->q[p->rear] = i;
    p->rear = (p->rear++) / maxnum;
    p->count++;

    while (p->count != 0){//假如队列不空
        //以下三行代码是去队列元素
        j = p->q[p->front];
        p->front = (p->rear++) / maxnum;
        p->count--;
        //寻找序号为i顶点的邻接点，并做如下处理
        for (k = 0; k<g->vNum; k++){
            if (g->e[j][k] != 0 && visited[k] == 0){//假如j点与i点相连，并且j点还没有被访问过
                printf("%d\n", k);//i已经被访问
                visited[k] = 1;//标记i边已经被访问

                //以下三行代码使得k进入队列
                p->q[p->rear] = k;
                p->rear = (p->rear++) / maxnum;
                p->count++;
            }
        }
    }
}

void BFS(graph *g){
    int i;
    //首先把所有点都设置成没有访问过
    for (i = 0; i<g->vNum; i++){
        visited[i] = 0;
    }
    //广度优先搜索
    for (i = 0; i<g->vNum; i++){
        if (visited[i] == 0){//假如i点没有被访问过
            bfs(g, i);//对以邻接矩阵表示的图，以序号为i的顶点为出发点进行广度优先搜索
        }
    }

}

