


重点在于递推公式



00000000000000000
0
0
0
0
0

等式右侧都是已知的！！！

#include <iostream>

#define N 8
#define M 7

char X[N + 1] = { ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H' };// 序列 X    X0不用
char Y[M + 1] = { ' ', 'B', 'D', 'G', 'H', 'A', 'F', 'A' };    // 序列 Y Y0不用



int Z[N + 1][M + 1]; //Z[i][j] 表示 {X1,...，Xi}与{Y1,...,Yj}的最长公共子序列长度
//Z[0][0] 表示 {} 与 {}
//Z[1][2] 表示 {X1} 与 {Y1,Y2}

int how[N + 1][M + 1]; //记录最长公子序列是如何得到的,用来追溯Z,得到具体的公共子序列
//how[i][j] = 0 表明记录 Z[i][j] = Z[i-1][j-1]+1，  X[i] == Y[j] 时;
//how[i][j] = 1 表明记录 Z[i][j] = Z[i-1][j]，  X[i] != Y[j] 时;
//how[i][j] = 2 表明记录 Z[i][j] = Z[i][j-1]，  X[i] != Y[j] 时;

/*----------------------------------------------------------------------------------
* 功  能: 求序列 X和Y的最长公共子序列的长度 [求最优解的值]
* 参  数：
* 返  回：无
------------------------------------------------------------------------------------*/
void LCSLength()
{
    int i, j;

    //X的{} 和 Y的{}{Y1}...{Y1,Y2}的公共子序列长度为0；同理有Y的{}
    for (i = 0; i<N; i++) Z[i][0] = 0;
    for (j = 0; j<M; j++) Z[0][j] = 0;

    //考虑其他情况，X和Y都顺序增长
    for (i = 1; i <= N; i++)
    {
        for (j = 1; j <= M; j++)
        {
            //X,Y当前元素相等，公共子序列长度加1
            if (X[i] == Y[j])
            {
                Z[i][j] = Z[i - 1][j - 1] + 1;
                how[i][j] = 0;
            }

            //Z[i][j] = max(Z[i-1][j],Z[i][j-1]);

            else if (Z[i - 1][j] >= Z[i][j - 1])
            {
                Z[i][j] = Z[i - 1][j];
                how[i][j] = 1;
            }
            else
            {
                Z[i][j] = Z[i][j - 1];
                how[i][j] = 2;
            }
        }
    }
}


/*----------------------------------------------------------------------------------
* 功  能: 追溯Z，得到具体的公共子序列 [求最优解]
* 参  数：
* 返  回：无
------------------------------------------------------------------------------------*/
void LCS(int i, int j)
{
    if (i == 0 || j == 0) return;

    if (how[i][j] == 0)
    {
        LCS(i - 1, j - 1);
        std::cout << X[i] << " ";
    }
    else if (how[i][j] == 1)
    {
        LCS(i - 1, j);
    }
    else
    {
        LCS(i, j - 1);
    }
}

int main()
{
    //最长公共子序列的长度
    LCSLength();
    std::cout << Z[N][M] << std::endl;//长度

    for(int i=0;i<=N;i++)
    {
        for(int j=0;j<=M;j++)
        {
            std::cout<<Z[i][j]<<"  ";
        }
        std::cout<<std::endl;
    }

    std::cout << std::endl;
    for (int i = 0; i <= N; i++)
    {
        for (int j = 0; j <= M; j++)
        {
            std::cout << how[i][j] << "  ";
        }
        std::cout << std::endl;
    }

    LCS(N, M);
    getchar();
    return 0;
}

