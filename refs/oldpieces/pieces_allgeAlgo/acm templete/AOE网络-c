
/* AOE网的关键路径问题C代码实现 */
#include <stdio.h>
#include <stdlib.h>

#define MaxSize 15

typedef int VertexType;

typedef struct Edge {
    VertexType begin;
    VertexType end;
    int weight;
}Edge;

typedef struct Graph {
    VertexType *ver;
    Edge *Edge;
    int VertexNum;
    int EdgeNum;
    int *In;
}Graph;

//创建AOE网
void CreateGraph(Graph **g, int nver, int nedg)
{
    int i, j;
    (*g) = (Graph *)malloc(sizeof(Graph));
    (*g)->VertexNum = nver;
    (*g)->EdgeNum = nedg;
    int EdgeNum = (*g)->EdgeNum;
    int VertexNum = (*g)->VertexNum;
    (*g)->Edge = (Edge *)malloc(sizeof(Edge)*(EdgeNum + 1));
    (*g)->In = (int *)malloc(sizeof(int)*(VertexNum + 1));
    (*g)->ver = (int *)malloc(sizeof(int)*(VertexNum + 1));

    printf("请输入AOE网的顶点:\n");
    for (i = 1; i <= VertexNum; i++)            //存储顶点
        scanf("%d", &(*g)->ver[i]);

    for (i = 1; i <= VertexNum; i++)            //顶点的入度数组初始化为0
        (*g)->In[i] = 0;

    printf("请输入AOE网的边的头、尾和权值:\n");
    for (i = 1; i <= EdgeNum; i++) {
        printf("a%d: ", i);
        scanf("%d %d %d", &((*g)->Edge[i].begin), &((*g)->Edge[i].end), &((*g)->Edge[i].weight));
        j = (*g)->Edge[i].end;
        (*g)->In[j]++;
    }
}

//关键路径查找函数
void FindCPath(Graph *g)
{
    int VertexNum = g->VertexNum;
    int EdgeNum = g->EdgeNum;
    int end;
    int TopIndex;
    int *Top = (int *)malloc(sizeof(int)*(VertexNum + 1));    //Top数组用来存储AOE网的拓扑序列的编号
    int *ve = (int *)malloc(sizeof(int)*(VertexNum + 1));     //ve[i]表示事件Vi的最早开始时间
    int *vl = (int *)malloc(sizeof(int)*(VertexNum + 1));     //vl[i]表示事件Vi的最迟开始时间
    int *e = (int *)malloc(sizeof(int)*(VertexNum + 1));      //e[i]表示活动ai的最早开始时间
    int *l = (int *)malloc(sizeof(int)*(VertexNum + 1));      //l[i]表示活动ai的最迟开始时间
    int i, j, k;

    for (i = 1; i <= VertexNum; i++)
    for (j = 1; j <= VertexNum; j++)
    if (0 == g->In[j]) {
        g->In[j] = -1;
        Top[i] = j;
        for (k = 1; k <= EdgeNum; k++)
        if (g->Edge[k].begin == g->ver[j]) {
            end = g->Edge[k].end;
            g->In[end]--;
        }
        break;
    }

    //求ve[i]
    for (i = 1; i <= VertexNum; i++)    //ve数组初始化
        ve[i] = 0;
    for (i = 1; i <= VertexNum; i++) {
        TopIndex = Top[i];
        for (j = 1; j <= EdgeNum; j++)
        if ((g->ver[TopIndex] == g->Edge[j].begin) && (ve[g->Edge[j].end] < ve[TopIndex] + g->Edge[j].weight))
            ve[g->Edge[j].end] = ve[TopIndex] + g->Edge[j].weight;
    }

    //求vl[i]
    for (i = 1; i <= VertexNum; i++)
        vl[i] = ve[VertexNum];
    for (i = VertexNum; i >= 1; i--) {
        TopIndex = Top[i];          //用逆拓扑序列求vl
        for (j = 1; j <= EdgeNum; j++)
        if ((g->Edge[j].end == g->ver[TopIndex]) && (vl[g->Edge[j].begin] > vl[TopIndex] - g->Edge[j].weight))
            vl[g->Edge[j].begin] = vl[TopIndex] - g->Edge[j].weight;
    }

    //求e[i]
    for (i = 1; i <= EdgeNum; i++)
        e[i] = ve[g->Edge[i].begin];

    //求l[i]
    for (i = 1; i <= EdgeNum; i++)
        l[i] = vl[g->Edge[i].end] - g->Edge[i].weight;

    printf("该AOE网的关键活动为:\n");
    for (i = 1; i <= EdgeNum; i++)
    if (e[i] == l[i])
        printf("a%d ", i);
    printf("\n");
}

int main()
{
    Graph *g;
    int VertexNum, EdgeNum;
    printf("请输入要创建的AOE网的顶点数和边数:\n");
    scanf("%d %d", &VertexNum, &EdgeNum);

    CreateGraph(&g, VertexNum, EdgeNum);
    FindCPath(g);
    getchar();
    return 0;
}

