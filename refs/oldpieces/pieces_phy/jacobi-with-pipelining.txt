/* Jacobi iteration using pthreads

   usage on Solaris:
     gcc jacobi.c -lpthread -lposix4
     a.out gridSize numWorkers numIters

    #define _REENTRANT
*/


#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <sys/times.h>
#include <limits.h>
#include <iostream>

#define SHARED 1
#define MAXGRID 258   /* maximum grid size, including boundaries */
#define MAXWORKERS 20  /* maximum number of worker threads */

void *Worker(void *);
void InitializeGrids();
void Barrier();

struct tms buffer;        /* used for timing */
clock_t start, finish;

pthread_mutex_t barrier;  /* mutex semaphore for the barrier */
pthread_cond_t go;        /* condition variable for leaving */
int numArrived = 0;       /* count of the number who have arrived */

int gridSize, numWorkers, numIters, stripSize;
double maxDiff[MAXWORKERS];
double grid1[MAXGRID][MAXGRID], grid2[MAXGRID][MAXGRID];


/*
 * Writes data to a 24-bit BMP file.
 * assumes input is dim x dim array
 */


/* main() -- read command line, initialize grids, and create threads
             when the threads are done, print the results */

int main(int argc, char *argv[]) {
  /* thread ids and attributes */
  pthread_t workerid[MAXWORKERS];
  pthread_attr_t attr;
  int i, j;
  double maxdiff = 0.0;
  FILE *results;

  /* set global thread attributes */
  pthread_attr_init(&attr);
  pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);

  /* initialize mutex and condition variable */
  pthread_mutex_init(&barrier, NULL);
  pthread_cond_init(&go, NULL);

  /* read command line and initialize grids */
  gridSize = 16;
  std::cin>>numWorkers ;//core , the only var .
  std::cin>>numIters;
  numIters = numIters + numWorkers - 1;// itr can change . 
  stripSize = gridSize/numWorkers;
  InitializeGrids();

  start = times(&buffer);
  /* create the workers, then wait for them to finish */
  for (i = 0; i < numWorkers; i++)
    pthread_create(&workerid[i], &attr, Worker, (void *)i);
  for (i = 0; i < numWorkers; i++)
    pthread_join(workerid[i], NULL);

  finish = times(&buffer);
  /* print the results */
  for (i = 0; i < numWorkers; i++)
    if (maxdiff < maxDiff[i])
      maxdiff = maxDiff[i];
  printf("number of iterations:  %d\nmaximum difference:  %e\n",
          numIters, maxdiff);
  printf("start:  %d   finish:  %d\n", start, finish);
  printf("elapsed time:  %d\n", finish-start);
  results = fopen("results", "w");
  for (i = 0; i <= gridSize+1; i++) {
    for (j = 0; j <= gridSize+1; j++) {
      fprintf(results, "%f ", grid2[i][j]);
    }
    fprintf(results, "\n");
  }

    int dimension = gridSize;
    // Open file.  Overwrites existing file if it exists
    FILE *bitFile;
    bitFile = fopen("output.bmp", "wb");
    // Write header
    int rowSize = 4 * ((int)((24 * dimension + 31) / 32));
    int fileSize = 54 + rowSize * dimension;
    char hd1[2] = {0x42, 0x4D};     // Magic Numbers
    short hd2[2] = {0x0, 0x0};      // Application Specific Values
    int offset = 54;
    int dibHeaderData1[3] = {40, dimension, dimension}; // header size, width, height
    short dibHeaderData2[2] = {1, 24};  // color planes, bits/pixel
    int dibHeaderData3[6] = {0, fileSize - offset, 2835, 2835, 0, 0};
                            // RGB, size of data, horz. resolution, vert res
    fwrite(hd1, 1, 2, bitFile);
    fwrite(&fileSize, 4, 1, bitFile);
    fwrite(hd2, 2, 2, bitFile);
    fwrite(&offset, 4, 1, bitFile);
    fwrite(dibHeaderData1, 4, 3, bitFile);
    fwrite(dibHeaderData2, 2, 2, bitFile);
    fwrite(dibHeaderData3, 4, 6, bitFile);
    // Write pixel data, starts from bottom row
    // each row should begin at a location in file that is a multiple of 4
    for(int i = dimension - 1; i >= 0; i--) {
        for(int j = 0; j < dimension; j++) {
            // BGR order
            char color[3] = {(char)(255 * (1 - grid2[i][j])),
                            0,
                            (char)(255 * grid2[i][j])};
            fwrite(color, 1, 3, bitFile);
        }
        // Check that next row will be at multiple of 4
        int remainder = (dimension * 3) % 4;
        if(remainder > 0) {
            char pad = 0;
            fwrite(&pad, remainder, 1, bitFile);
        }
    }
    fclose(bitFile);
}


/* Each Worker computes values in one strip of the grids.
   The main worker loop does two computations to avoid copying from
   one grid to the other.  */

void *Worker(void *arg) {
  int myid = (int) arg;
  double maxdiff, temp;
  int i, j, iters;
  int first, last;

  printf("worker %d (pthread id %d) has started\n", myid, pthread_self());

  /* determine first and last rows of my strip of the grids */
  first = myid * stripSize + 1;
  last = first + stripSize - 1;

  int skipw1,skipw2;
 
  for (iters = 1; iters <= numIters; iters++) {
    /* update my points */
    if(numWorkers>1){
        skipw1=myid+1;
        skipw2=numIters-numWorkers+myid+1;
        //std::cout<<skipw1<<skipw2<<std::endl;
        if(iters<skipw1||iters>skipw2){
             printf("worker %d skip at %d itr !\n",myid,iters);
        }else{
            for (i = first; i <= last; i++) {
              for (j = 1; j <= gridSize; j++) {
                grid2[i][j] = (grid1[i-1][j] + grid1[i+1][j] + grid1[i][j-1] + grid1[i][j+1]) * 0.25;
              }
            }
            Barrier();
            /* update my points again */
            for (i = first; i <= last; i++) {
              for (j = 1; j <= gridSize; j++) {
                grid1[i][j] = (grid2[i-1][j] + grid2[i+1][j] + grid2[i][j-1] + grid2[i][j+1]) * 0.25;
              }
            }
            printf("worker %d wait here!\n",myid);
            Barrier();
        }
        
        
    }
    else{
        for (i = first; i <= last; i++) {
              for (j = 1; j <= gridSize; j++) {
                grid2[i][j] = (grid1[i-1][j] + grid1[i+1][j] + grid1[i][j-1] + grid1[i][j+1]) * 0.25;
              }
            }
            // we should do it again to heat transfer.
            for (i = first; i <= last; i++) {
              for (j = 1; j <= gridSize; j++) {
                grid1[i][j] = (grid2[i-1][j] + grid2[i+1][j] + grid2[i][j-1] + grid2[i][j+1]) * 0.25;
              }
            }
      }
    
  }
  /* compute the maximum difference in my strip and set global variable */
  maxdiff = 0.0;
  for (i = first; i <= last; i++) {
    for (j = 1; j <= gridSize; j++) {
      temp = grid1[i][j]-grid2[i][j];
      if (temp < 0)
        temp = -temp;
      if (maxdiff < temp)
        maxdiff = temp;
    }
  }
  maxDiff[myid] = maxdiff;
}

void InitializeGrids() {
  /* initialize the grids (grid1 and grid2)
     set boundaries to 1.0 and interior points to 0.0  */
  int i, j;
  for (i = 0; i <= gridSize+1; i++)
    for (j = 0; j <= gridSize+1; j++) {
      grid1[i][j] = 0.0;
      grid2[i][j] = 0.0;
    }
  for (i = 0; i <= gridSize+1; i++) {
    grid1[i][0] = 1.0;
    //grid1[i][gridSize+1] = 1.0;
     grid2[i][0] = 1.0;
    //grid2[i][gridSize+1] = 1.0;
  }
  for (j = 0; j <= gridSize+1; j++) {
    //grid1[0][j] = 1.0;
    //grid2[0][j] = 1.0;
    //grid1[gridSize+1][j] = 1.0;
    //grid2[gridSize+1][j] = 1.0;
  }
}

void Barrier() {
  pthread_mutex_lock(&barrier);
  numArrived++;
  if (numArrived == numWorkers) {
    numArrived = 0;
    pthread_cond_broadcast(&go);
    printf("go from here\n");
  } else
    pthread_cond_wait(&go, &barrier);
  pthread_mutex_unlock(&barrier);
}
