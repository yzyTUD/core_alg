#define _CRT_SECURE_NO_DEPRECATE
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <time.h>

#define SIZE 16


float **makeArray2f(int width, int height);
void freeArray2f(float **arr, int width);
bool generateBMP(float **data, char *filePath, int dimension);
bool write2file(float **data, char *filePath, int dimension);

int main(int argc, char** argv) {
	
	float** arr1 = makeArray2f(SIZE, SIZE);
	float** arr2 = makeArray2f(SIZE, SIZE);

	// initialize.  initial grid will look like:
	// 1 1 1 1...
	// 1 0 0 0...
	// 1 0 0 0...
	// 1 0 0 0...
	for (int i = 0; i < SIZE; i++) {
		for (int j = 0; j < SIZE; j++) {
			if (j == 0)
				arr2[i][j] = arr1[i][j] = 1; // hot at top and left
			else
				arr2[i][j] = arr1[i][j] = 0;
		}
	}


	// Do sequential heat transfer, ignores a 1-cell border on all 4 sides
	int itr = 0;
	do {
		for (int i = 1; i < SIZE - 1; i++) {
			for (int j = 1; j < SIZE - 1; j++) {
				arr2[i][j] = (float)(0.25*(arr1[i - 1][j] + arr1[i + 1][j] +
					arr1[i][j - 1] + arr1[i][j + 1]));
			}
		}
		float** temp = arr1;
		arr1 = arr2;
		arr2 = temp;

		itr++;
		if (itr % 100000 == 0) {
			printf("current itr = %d , arr[][] = %f \n", itr, arr1[SIZE / 2 - 1][SIZE - 2]);

			const int LOGNAME_SIZE = 24;
			char name[LOGNAME_SIZE];
			time_t now = time(0);
			strftime(name, sizeof(name), "log/%Y%m%d_%H%M%S.txt", localtime(&now));
			write2file(arr1, name, SIZE);
		}
			
	} while (
		//arr1[SIZE/2-1][SIZE-2]<0.023
		itr < 1000000
	);


	printf("Done,itr = %d arr[][] = %f\n",itr, arr1[SIZE / 2 - 1][SIZE - 2]);
	generateBMP(arr1, (char *)"sequential.bmp", SIZE);
	write2file(arr1, (char *)"sequential.txt", SIZE);

	freeArray2f(arr1, SIZE);
	freeArray2f(arr2, SIZE);
	int i = 0;
	std::cin >> i;
	return 0;
}
/*
 * dynamic 2D array of floats allocation
 */
float **makeArray2f(int width, int height) {
	size_t rowSize = sizeof(float*) * width;
	size_t colSize = sizeof(float) * height;
	float **result = (float**)malloc(rowSize);
	for (int i = 0; i < width; i++) {
		result[i] = (float*)malloc(colSize);
	}
	return result;
}

/*
 * Frees memory from a 2D float array
 */
void freeArray2f(float **arr, int width) {
	for (int i = 0; i < width; i++) {
		free(arr[i]);
	}
	free(arr);
}

/*
 * Writes data to a 24-bit BMP file.
 * assumes input is dim x dim array
 */
bool generateBMP(float **data, char *filePath, int dimension) {
	// Open file.  Overwrites existing file if it exists
	FILE *bitFile;
	if (!(bitFile = fopen(filePath, "wb"))) return false;
	// Write header
	int rowSize = 4 * ((int)((24 * dimension + 31) / 32));
	int fileSize = 54 + rowSize * dimension;
	char hd1[2] = { 0x42, 0x4D };     // Magic Numbers
	short hd2[2] = { 0x0, 0x0 };      // Application Specific Values
	int offset = 54;
	int dibHeaderData1[3] = { 40, dimension, dimension }; // header size, width, height
	short dibHeaderData2[2] = { 1, 24 };  // color planes, bits/pixel
	int dibHeaderData3[6] = { 0, fileSize - offset, 2835, 2835, 0, 0 };
	// RGB, size of data, horz. resolution, vert res
	fwrite(hd1, 1, 2, bitFile);
	fwrite(&fileSize, 4, 1, bitFile);
	fwrite(hd2, 2, 2, bitFile);
	fwrite(&offset, 4, 1, bitFile);
	fwrite(dibHeaderData1, 4, 3, bitFile);
	fwrite(dibHeaderData2, 2, 2, bitFile);
	fwrite(dibHeaderData3, 4, 6, bitFile);
	// Write pixel data, starts from bottom row
	// each row should begin at a location in file that is a multiple of 4
	for (int i = dimension - 1; i >= 0; i--) {
		for (int j = 0; j < dimension; j++) {
			// BGR order
			char color[3] = { (char)(255 * (1 - data[i][j])),
							0,
							(char)(255 * data[i][j]) };
			fwrite(color, 1, 3, bitFile);
		}
		// Check that next row will be at multiple of 4
		int remainder = (dimension * 3) % 4;
		if (remainder > 0) {
			char pad = 0;
			fwrite(&pad, remainder, 1, bitFile);
		}
	}
	fclose(bitFile);
	return true;
}
bool write2file(float **data, char *filePath, int dimension) {

	FILE * results = fopen(filePath, "w");
	for (int i = 0; i < dimension; i++) {
		for (int j = 0; j < dimension; j++) {
			fprintf(results, "%.6f ", data[i][j]);
		}
		fprintf(results, "\n");
	}
	return true;
}