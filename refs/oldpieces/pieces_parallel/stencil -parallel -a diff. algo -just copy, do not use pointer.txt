#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <pthread.h>
#include <iostream>

#define SIZE 16

float **makeArray2f(int width, int height);
void freeArray2f(float **arr, int width);
bool generateBMP(float **data, char *filePath, int dimension);
bool write2file(float **data,char *filePath, int dimension);

/*
	vars related to pthread -as header 
*/
void *doStencil(void *);
void Barrier();
pthread_mutex_t barrier;  /* mutex semaphore for the barrier */
pthread_cond_t go;        /* condition variable for leaving */
int numArrived=0,numWorkers = 0;       /* count of the number who have arrived */

// pthread structure para.
struct arguments {
    float **array1;
    float **array2;
    int id;
    int nIter;
};



/*
	pthread worker function (real part) -as header 
*/
void *doStencil(void *param) {
    struct arguments *args;
    int numIter, id;
    float **arr1;
    float **arr2;
    
	// get argum.
    args = (struct arguments*)param;
    numIter = args->nIter;
    arr1 = args->array1;
    arr2 = args->array2;
    id = args->id;

	// devide data
    int lowRow = (id%(numWorkers/2)) * (SIZE/(numWorkers/2));
    int highRow = lowRow + (SIZE / (numWorkers/2));
    int lowCol = (id/(numWorkers/2)) * (SIZE/(numWorkers/2));
    int highCol = lowCol + (SIZE/(numWorkers/2));

    // impliment stencil 
    for(int t = 0; t < numIter; t++) {
        for(int i = lowRow; i < highRow; i++) {
            for(int j = lowCol; j < highCol; j++) {
                // update cell if applicable
                if(i > 0 && j > 0 && i < SIZE-1 && j < SIZE-1) {
                    arr2[i][j] = (float)(0.25*(arr1[i-1][j] + arr1[i+1][j] + 
						arr1[i][j-1] + arr1[i][j+1]));
					//std::cout<< "this is worker :"<<id<<"updating "<<std::endl;
                }
            }
        }
		Barrier();
        for(int i = lowRow; i < highRow; i++) {
            for(int j = lowCol; j < highCol; j++) {
                    arr1[i][j] = arr2[i][j];
            }
        }
		Barrier();
	}
	return NULL;
}

/*
	Main Function 
*/
int main(int argc, char** argv) {
    int nIter = 10;
	std::cin>> numWorkers;
	std::cin>> nIter;
	// create arrays to hold data
	// create arrays to hold data
    //size_t size = sizeof(float) * SIZE * SIZE;
    float** arr1 = makeArray2f(SIZE, SIZE);
    float** arr2 = makeArray2f(SIZE, SIZE);

    // initialize.  initial grid will look like:
    // 1 1 1 1...
    // 1 0 0 0...
    // 1 0 0 0...
    // 1 0 0 0...
    for(int i = 0; i < SIZE; i++) {
        for(int j = 0; j < SIZE; j++) {
            if(j == 0)
                arr2[i][j] = arr1[i][j] = 1; // hot at top and left
            else
                arr2[i][j] = arr1[i][j] = 0;
        }
    }

    /*
		do sequential heat transfer
	*/ 
    for(int t = 0; t < nIter; t++) {
        for(int i = 1; i < SIZE - 1; i++) {
            for(int j = 1; j < SIZE - 1; j++) {
                arr2[i][j] = (float)(0.25*(arr1[i-1][j] + arr1[i+1][j] +
					arr1[i][j-1] + arr1[i][j+1]));
            }
        }
        for(int i = 1; i < SIZE - 1; i++) {
            for(int j = 1; j < SIZE - 1; j++) {
                arr1[i][j] = arr2[i][j];
            }
        }
		// arr2 is used just for temp file 
    }

	
	/**
		do thread create -in main function 
	*/
	pthread_t workerid[numWorkers];

	float** ptArr1 = makeArray2f(SIZE, SIZE);
    float** ptArr2 = makeArray2f(SIZE, SIZE);
    // initialize
    for(int i = 0; i < SIZE; i++) {
        for(int j = 0; j < SIZE; j++) {
            if(j == 0)
                ptArr2[i][j] = ptArr1[i][j] = 1; // hot at left
            else
                ptArr2[i][j] = ptArr1[i][j] = 0;
        }
    }
    struct arguments arg[numWorkers];
    // create threads
    for(int i = 0; i < numWorkers; i++) {
        // set args
        arg[i].nIter = nIter;
        arg[i].id = i;
        arg[i].array1 = ptArr1;
        arg[i].array2 = ptArr2;
		std::cout<< "starting thread "<<i<<std::endl;
        pthread_create(&workerid[i], NULL, doStencil, (void*)&arg[i]);
    }
    // Wait for all threads to complete
    for(int i = 0; i < numWorkers; i++) {
        pthread_join(workerid[i], NULL);
    }


    printf("Done\n");
    generateBMP(arr2, "sequential.bmp", SIZE);
	write2file(arr2, "sequential.txt", SIZE);
	//ptArr1
    generateBMP(ptArr2, "pthread.bmp", SIZE);
	write2file(ptArr2, "pthread.txt", SIZE);

    freeArray2f(arr1, SIZE);
    freeArray2f(arr2, SIZE);
    freeArray2f(ptArr1, SIZE);
    freeArray2f(ptArr2, SIZE);
	return 0;
}



/*
 * dynamic 2D array of floats allocation 
 */
float **makeArray2f(int width, int height) {
    size_t rowSize = sizeof(float*) * width;
    size_t colSize = sizeof(float) * height;
    float **result = (float**)malloc(rowSize);
    for(int i = 0; i < width; i++) {
        result[i] = (float*)malloc(colSize);
    }
    return result;
}

/*
 * Frees memory from a 2D float array
 */
void freeArray2f(float **arr, int width) {
    for(int i = 0; i < width; i++) {
        free(arr[i]);
    }
    free(arr);
}

/*
 * Writes data to a 24-bit BMP file.
 * assumes input is dim x dim array
 */
bool generateBMP(float **data, char *filePath, int dimension) {
    // Open file.  Overwrites existing file if it exists
    FILE *bitFile;
    if(!(bitFile = fopen(filePath, "wb"))) return false;
    // Write header
    int rowSize = 4 * ((int)((24 * dimension + 31) / 32));
    int fileSize = 54 + rowSize * dimension;
    char hd1[2] = {0x42, 0x4D};     // Magic Numbers
    short hd2[2] = {0x0, 0x0};      // Application Specific Values
    int offset = 54;
    int dibHeaderData1[3] = {40, dimension, dimension}; // header size, width, height
    short dibHeaderData2[2] = {1, 24};  // color planes, bits/pixel
    int dibHeaderData3[6] = {0, fileSize - offset, 2835, 2835, 0, 0};
                            // RGB, size of data, horz. resolution, vert res
    fwrite(hd1, 1, 2, bitFile);
    fwrite(&fileSize, 4, 1, bitFile);
    fwrite(hd2, 2, 2, bitFile);
    fwrite(&offset, 4, 1, bitFile);
    fwrite(dibHeaderData1, 4, 3, bitFile);
    fwrite(dibHeaderData2, 2, 2, bitFile);
    fwrite(dibHeaderData3, 4, 6, bitFile);
    // Write pixel data, starts from bottom row
    // each row should begin at a location in file that is a multiple of 4
    for(int i = dimension - 1; i >= 0; i--) {
        for(int j = 0; j < dimension; j++) {
            // BGR order
            char color[3] = {(char)(255 * (1 - data[i][j])),
                            0,
                            (char)(255 * data[i][j])};
            fwrite(color, 1, 3, bitFile);
        }
        // Check that next row will be at multiple of 4
        int remainder = (dimension * 3) % 4;
        if(remainder > 0) {
            char pad = 0;
            fwrite(&pad, remainder, 1, bitFile);
        }
    }
    fclose(bitFile);
    return true;
}
bool write2file(float **data,char *filePath, int dimension){

	FILE * results = fopen(filePath, "w");
	for (int i = 0; i < dimension; i++) {
		for (int j = 0; j < dimension; j++) {
			fprintf(results, "%.6f ", data[i][j]);
			}
				fprintf(results, "\n");
			}
	return true ;
}
void Barrier() {
	pthread_mutex_lock(&barrier);
	numArrived++;
	if (numArrived == numWorkers) {
		//std::cout<< "go!"<<std::endl;
		numArrived = 0;
		pthread_cond_broadcast(&go);
	} else
		pthread_cond_wait(&go, &barrier);
	pthread_mutex_unlock(&barrier);
}





