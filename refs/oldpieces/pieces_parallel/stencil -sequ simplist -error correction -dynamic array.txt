#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <pthread.h>
#include <iostream>

#define SIZE 16
#define NUM_THREADS 2

float **makeArray2f(int width, int height);
void freeArray2f(float **arr, int width);
bool generateBMP(float **data, char *filePath, int dimension);
bool write2file(float **data,char *filePath, int dimension);

int main(int argc, char** argv) {
    int nIter = 100;
	//pthread_t thread[NUM_THREADS];
	// create arrays to hold data
	// create arrays to hold data
    //size_t size = sizeof(float) * SIZE * SIZE;
    float** arr1 = makeArray2f(SIZE, SIZE);
    float** arr2 = makeArray2f(SIZE, SIZE);

    // initialize.  initial grid will look like:
    // 1 1 1 1...
    // 1 0 0 0...
    // 1 0 0 0...
    // 1 0 0 0...
    for(int i = 0; i < SIZE; i++) {
        for(int j = 0; j < SIZE; j++) {
            if(j == 0)
                arr2[i][j] = arr1[i][j] = 1; // hot at top and left
            else
                arr2[i][j] = arr1[i][j] = 0;
        }
    }

    // Do sequential heat transfer, ignores a 1-cell border on all 4 sides
    for(int t = 0; t < nIter; t++) {
        for(int i = 1; i < SIZE - 1; i++) {
            for(int j = 1; j < SIZE - 1; j++) {
                arr2[i][j] = (float)(0.25*(arr1[i-1][j] + arr1[i+1][j] +
					arr1[i][j-1] + arr1[i][j+1]));
            }
        }
        float** temp = arr1;
        arr1 = arr2;
        arr2 = temp;
    }


    printf("Done\n");
    generateBMP(arr1, "sequential.bmp", SIZE);
	write2file(arr1, "sequential.txt", SIZE);

    freeArray2f(arr1, SIZE);
    freeArray2f(arr2, SIZE);
	return 0;
}
/*
 * dynamic 2D array of floats allocation 
 */
float **makeArray2f(int width, int height) {
    size_t rowSize = sizeof(float*) * width;
    size_t colSize = sizeof(float) * height;
    float **result = (float**)malloc(rowSize);
    for(int i = 0; i < width; i++) {
        result[i] = (float*)malloc(colSize);
    }
    return result;
}

/*
 * Frees memory from a 2D float array
 */
void freeArray2f(float **arr, int width) {
    for(int i = 0; i < width; i++) {
        free(arr[i]);
    }
    free(arr);
}

/*
 * Writes data to a 24-bit BMP file.
 * assumes input is dim x dim array
 */
bool generateBMP(float **data, char *filePath, int dimension) {
    // Open file.  Overwrites existing file if it exists
    FILE *bitFile;
    if(!(bitFile = fopen(filePath, "wb"))) return false;
    // Write header
    int rowSize = 4 * ((int)((24 * dimension + 31) / 32));
    int fileSize = 54 + rowSize * dimension;
    char hd1[2] = {0x42, 0x4D};     // Magic Numbers
    short hd2[2] = {0x0, 0x0};      // Application Specific Values
    int offset = 54;
    int dibHeaderData1[3] = {40, dimension, dimension}; // header size, width, height
    short dibHeaderData2[2] = {1, 24};  // color planes, bits/pixel
    int dibHeaderData3[6] = {0, fileSize - offset, 2835, 2835, 0, 0};
                            // RGB, size of data, horz. resolution, vert res
    fwrite(hd1, 1, 2, bitFile);
    fwrite(&fileSize, 4, 1, bitFile);
    fwrite(hd2, 2, 2, bitFile);
    fwrite(&offset, 4, 1, bitFile);
    fwrite(dibHeaderData1, 4, 3, bitFile);
    fwrite(dibHeaderData2, 2, 2, bitFile);
    fwrite(dibHeaderData3, 4, 6, bitFile);
    // Write pixel data, starts from bottom row
    // each row should begin at a location in file that is a multiple of 4
    for(int i = dimension - 1; i >= 0; i--) {
        for(int j = 0; j < dimension; j++) {
            // BGR order
            char color[3] = {(char)(255 * (1 - data[i][j])),
                            0,
                            (char)(255 * data[i][j])};
            fwrite(color, 1, 3, bitFile);
        }
        // Check that next row will be at multiple of 4
        int remainder = (dimension * 3) % 4;
        if(remainder > 0) {
            char pad = 0;
            fwrite(&pad, remainder, 1, bitFile);
        }
    }
    fclose(bitFile);
    return true;
}
bool write2file(float **data,char *filePath, int dimension){

	FILE * results = fopen(filePath, "w");
	for (int i = 0; i < dimension; i++) {
		for (int j = 0; j < dimension; j++) {
			fprintf(results, "%.6f ", data[i][j]);
			}
				fprintf(results, "\n");
			}
	return true ;
}





